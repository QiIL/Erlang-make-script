#!/usr/bin/env escript
%% vim: set ft=erlang:
%% coding: utf-8
-include_lib("kernel/include/file.hrl").
-define(EXIT, halt(1)).
-define(EASY_MAKE_CONFIG, "./script/easy_make.config").
-define(GAME_PROTO, "./proto/game_proto.txt").
-define(PROTO_IDS, "./proto/proto_id.txt").
-define(GOOGLE_GAME_PROTO, "./proto/game_proto.proto").
-define(ALL_CHECK_DIR, [
    "./src/proto/",
    "./include/proto/"
]).
-define(ROLE_MOD_IGNORE_LIST, []).

-define(MAP_KEY_NAME,    name).
-define(MAP_KEY_NOTE,    note).
-define(MAP_KEY_FIELD,   fields).
-define(MAP_KEY_ROUTER,  router).
-define(MAP_KEY_ERRCODE, err_code).
-define(MAP_KEY_ACK, ack).

-ifndef(IF).
-define(IF(C, T, F), (case (C) of true -> (T); false -> (F) end)).
-endif.

abort(Fmt, Args) ->
    io:format("ERROR: " ++ Fmt ++ "~n", Args),
    ?EXIT.

get_file_head() ->
    "%% ---------------------------------------------------------\n"
    "%% This file is generated by script, DO NOT EDIT!\n"
    "%% ---------------------------------------------------------\n".

main([]) ->
    ensure_dir(),
    gen_all().

gen_all() ->
    io:format("Processing......[please do not close this window!]~n"),
    {ok, [{proto_list, ProtoList}, {common_error_list, ErrorList}]} = file:consult(?GAME_PROTO),
    check_proto_list(ProtoList),
    io:format("~s success~n", ["proto_format_check"]),
    ProtoIDList = gen_proto_id(ProtoList),
    set_proto_id_txt(ProtoIDList),
    io:format("~s success~n", ["gen_proto_id"]),
    check_error_no(ProtoList, ErrorList),
    io:format("~s success~n", ["check_error_no"]),

    {CommonProtoList, HrlList, _RoleModList} = gen_hrl_list(ProtoList),
    FList =
        [
            {fun() -> gen_proto_file(ProtoList) end, "gen_proto_file"}
%%
%%            {fun() -> gen_proto_router(ProtoList) end, "gen_proto_router"},
%%            {fun() -> gen_gateway_proto_id(ProtoList) end, "gen_gateway_proto_id"},
%%            {fun() -> gen_proto_ack_erl(ProtoList) end, "gen_proto_ack_erl"},
%%            {fun() -> gen_proto_ack_lua(ProtoList) end, "gen_proto_ack_lua"},
%%            {fun() -> gen_proto_switch(ProtoList) end, "gen_proto_switch"},
%%
%%            {fun() -> gen_proto_hrl(HrlList) end, "gen_proto_hrl"},
%%            {fun() -> gen_common_pb_hrl(CommonProtoList) end, "gen_common_pb_hrl"},
%%            {fun() -> gen_common_error_no(CommonProtoList, ErrorList) end, "gen_common_error_no"},
%%            {fun() -> gen_all_pb_hrl(HrlList) end, "gen_all_pb_hrl"},
%%            {fun() -> gen_all_error_no(ProtoList, ErrorList) end, "gen_all_error_no"},
        ],
    process_flag(trap_exit, true),
    PidList = [ {erlang:spawn_link(F), Msg} || {F, Msg} <- FList ],
    [] = lists:foldl(fun(_T, Acc)->
        receive
            {'EXIT', Pid, normal} ->
                {_, Msg} = lists:keyfind(Pid, 1, Acc),
                io:format("~s success~n", [Msg]),
                lists:keydelete(Pid, 1, Acc);
            {'EXIT', Pid, Err} ->
                {_, Msg} = lists:keyfind(Pid, 1, Acc),
                io:format("~s error: ~w~n", [Msg, Err]),
                [ catch erlang:exit(P, kill) || {P, _} <- Acc],
                erlang:throw({error, Pid});
            _Err ->
                io:format("~w error~n", [_Err]),
                [ catch erlang:exit(P, kill) || {P, _} <- Acc],
                erlang:throw({error, _Err})
        end
    end, PidList, PidList),
    process_flag(trap_exit, false),
    gen_gpb(),
    ok.
write_file(FileName, Bytes, Modes) ->
    ok = filelib:ensure_dir(FileName),
    ok = file:write_file(FileName, Bytes, Modes).

ensure_dir() ->
    [ensure_dir(Dir) || Dir <- ?ALL_CHECK_DIR].
ensure_dir(Dir) ->
    case filelib:is_dir(Dir) of
        true -> ok;
        false ->
            file:make_dir(Dir)
    end.


%%======================== 检查check_proto_list start ==============================
%% @doc 做game.proto文件的格式检查
check_proto_list(ProtoList) ->
    lists:foreach(fun(Map) ->
        case erlang:is_map(Map) of
            true ->
                check_map_name(Map),
                check_tos_router(Map);
            _ ->
                abort("map format error: ~w", [Map])
        end end, ProtoList),
    check_duplicates(ProtoList),
    check_missing_router().

%% @doc 检查map name
check_map_name(Map) ->
    case maps:find(?MAP_KEY_NAME, Map) of
        {ok, Name} ->
            Tokens = string:tokens(to_list(Name), "_"),
            FirstKey = hd(Tokens),
            LastKey = lists:last(Tokens),
            if FirstKey =:= "m", LastKey =:= "tos" -> ok;
                FirstKey =:= "m", LastKey =:= "toc" -> ok;
                FirstKey =:= "p" -> ok;
                true ->
                    abort("unknown name format: ~w", [Name])
            end;
        _ ->
            abort("missing name: ~w", [Map])
    end.

%% @doc 检查tos的map中有没有router
check_tos_router(#{?MAP_KEY_NAME := Name} = Map) ->
    Tokens = string:tokens(to_list(Name), "_"),
    FirstKey = hd(Tokens),
    LastKey = lists:last(Tokens),
    case FirstKey =:= "m" andalso LastKey =:= "tos" of
        true ->
            case maps:find(?MAP_KEY_ROUTER, Map) of
                {ok, _Router} ->
                    ok;
                _ ->
                    set_missing_router(Name)
            end;
        _ ->
            ignore
    end.

%% @doc map重复检查
check_duplicates(ProtoList) ->
    MapNameList = [Name || #{?MAP_KEY_NAME := Name} <- ProtoList],
    case get_duplicates_list(MapNameList) of
        [] ->
            ok;
        RepeatLs ->
            abort("redefining names: ~w", [RepeatLs])
    end.

get_duplicates_list(MapNameList) ->
    Uniques = lists:usort(MapNameList),
    lists:usort(MapNameList -- Uniques).

%% @doc tos缺少router属性的情况
check_missing_router() ->
    case get_missing_router() of
        [] ->
            ok;
        L ->
            abort("missing router: ~w", [L])
    end.

%% @doc 放置缺失的tos router
set_missing_router(Name) ->
    erlang:put(missing_router, [Name|get_missing_router()]).
get_missing_router() ->
    case erlang:get(missing_router) of
        undefined -> [];
        L -> L
    end.


%%======================== 生成proto_id.txt  start ==============================
%% @returns [{Name, ID}]
gen_proto_id(ProtoList) ->
    case filelib:is_file(?PROTO_IDS) of
        true ->
            {ok, ProtoIDList} = file:consult(?PROTO_IDS),
            IDs = [ID || {_, ID} <- ProtoIDList],
            case IDs of
                [] -> LastID = 0;
                _ -> LastID = lists:max(IDs)
            end,
            set_last_proto_id(LastID),
            AddList = get_add_list(ProtoList, ProtoIDList),
            do_append_file(AddList, ProtoIDList);
        _ ->
            {AddList, _} = lists:foldl(
                fun(#{?MAP_KEY_NAME := Name}, {AccList, AccCount}) ->
                    {[{Name, AccCount}|AccList], AccCount + 1}
                end, {[], 1}, ProtoList),
            do_append_file(AddList, [])
    end.

get_add_list(ProtoList, ProtoIDList) ->
    [{Name, inc_last_proto_id()} || #{?MAP_KEY_NAME := Name} <- ProtoList,
        not lists:keymember(Name, 1, ProtoIDList)].

do_append_file([], ProtoIDList) ->
    ProtoIDList;
do_append_file(AddList, OldList) ->
    ?IF(OldList =/= [], next, write_head()),
    AddList1 = lists:keysort(2, AddList),
    [file:write_file(?PROTO_IDS, io_lib:format("~w.~n", [Add]), [append]) || Add <- AddList1],
    AddList ++ OldList.

write_head() ->
    file:write_file(?PROTO_IDS, get_file_head()).

%% 设置proto_id.txt中的最后一个id
set_last_proto_id(LastID) ->
    erlang:put(last_proto_id, LastID).

get_last_proto_id() ->
    erlang:get(last_proto_id).

inc_last_proto_id() ->
    LastID = get_last_proto_id(),
    set_last_proto_id(LastID + 1) + 1.

%% @doc 将生成好的proto_id.txt内容放入内存
set_proto_id_txt(ProtoIDList) ->
    ets:new(proto_ids, [public, set, named_table, {read_concurrency, true}]),
    ets:insert(proto_ids, {all_proto_id, ProtoIDList}),
    [ets:insert(proto_ids, {{proto_id, Name}, ID}) || {Name, ID} <- ProtoIDList],
    ok.

%%%% @returns [{Name, ID}]
%%get_all_proto_id() ->
%%    [{_, ProtoIDList}] = ets:lookup(proto_ids, all_proto_id),
%%    ProtoIDList.
%%

get_map_id(Map) when erlang:is_map(Map) ->
    {ok, Name} = maps:find(?MAP_KEY_NAME, Map),
    get_map_id(Name);
get_map_id(Name) ->
    get_proto_id(Name).
%% @returns ID | undefined
get_proto_id(Name) ->
    case ets:lookup(proto_ids, {proto_id, Name}) of
        [{_, ID}] -> ID;
        _ -> undefined
    end.


%% @doc ======================== 检查错误码合法性, 无重复 start ==============================
check_error_no(ProtoList, ErrorList) ->
    IDs1 = check_error_list(ErrorList, []),
    check_proto_error_list(ProtoList, IDs1).

check_error_list([{ErrorCode, _Define, _Note, _NotifyType}|ErrorList], Acc) ->
    case lists:member(ErrorCode, Acc) of
        true ->
            abort("duplicate error code: ~w", [ErrorCode]);
        _ ->
            check_error_list(ErrorList, [ErrorCode|Acc])
    end;
check_error_list([{ErrorCode, _Define, _Note}|ErrorList], Acc) ->
    case lists:member(ErrorCode, Acc) of
        true ->
            abort("duplicate error code: ~w", [ErrorCode]);
        _ ->
            check_error_list(ErrorList, [ErrorCode|Acc])
    end;
check_error_list([Other|_], _) ->
    abort("illegal error list format: ~w", [Other]);
check_error_list([], IDs) ->
    IDs.

check_proto_error_list([#{?MAP_KEY_NAME := Name} = Map|ProtoList], IDs) ->
    case maps:find(?MAP_KEY_ERRCODE, Map) of
        {ok, [_|_] = ErrorList} ->
            ID = get_map_id(Map),
            IDs2 = check_proto_error_list2(ErrorList, ID, Name, IDs);
        _ ->
            IDs2 = IDs
    end,
    check_proto_error_list(ProtoList, IDs2);
check_proto_error_list([], _) ->
    ok.

check_proto_error_list2([{Num, _Note}|ErrorList], ID, Name, IDs) ->
    ErrorCode = gen_error_code(ID, Name, Num),
    case lists:member(ErrorCode, IDs) of
        true ->
            abort("duplicate error code: ~w, for proto ~w", [ErrorCode, Name]);
        _ ->
            check_proto_error_list2(ErrorList, ID, Name, [ID|IDs])
    end;
check_proto_error_list2([{Num, Note, _ShowType}|ErrorList], ID, Name, IDs) ->
    check_proto_error_list2([{Num, Note}|ErrorList], ID, Name, IDs);
check_proto_error_list2([Other|_], _ID, Name, _IDs) ->
    abort("illegal error code format: ~w, for proto: ~w", [Other, Name]);
check_proto_error_list2([], _, _, IDs) ->
    IDs.

gen_error_code(ID, _Name, Num) when is_integer(Num), Num < 1000 ->
    ID * 1000 + Num;
gen_error_code(_ID, Name, Num) ->
    abort("illegal error code: ~w, for proto: ~w", [Num, Name]).

%% ======================== 检查错误码合法性, 无重复 end ==============================

%%=============================
%% @returns {L1, L2, L3}
%%          L1 := [ProtoMap], 未定义router的清单
%%          L2 := [{HrlName, [ProtoMap]}]
%%          L3 := [{RoleModule, [ProtoName]}]
gen_hrl_list(ProtoList) ->
    {OtherList, HrlList, RoleModList} =
        lists:foldl(
            fun(Map, {OtherAcc, HrlsAcc, RoleModAcc}) ->
                case maps:find(?MAP_KEY_ROUTER, Map) of
                    {ok, Router} ->
                        HrlName = get_hrl_name(Router),
                        case lists:keyfind(HrlName, 1, HrlsAcc) of
                            {_, HrlsAcc0} -> ok;
                            _ -> HrlsAcc0 = []
                        end,
                        HrlsAcc2 = lists:keystore(HrlName, 1, HrlsAcc, {HrlName, [Map|HrlsAcc0]}),
                        RoleModAcc2 = get_role_mod(Map, Router, RoleModAcc),
                        {OtherAcc, HrlsAcc2, RoleModAcc2};
                    _ ->
                        {[Map|OtherAcc], HrlsAcc, RoleModAcc}
                end
            end, {[], [], []}, ProtoList),
    RoleModList2 = del_ignore_list(?ROLE_MOD_IGNORE_LIST, RoleModList),
    {OtherList, HrlList, RoleModList2}.
get_hrl_name(Router) ->
    case Router of
        {Value} ->
            Value;
        {_Value, Mod} ->
            Mod;
        _ ->
            Router
    end.

get_role_mod(Map, Router, RoleModAcc) ->
    case Router of
        {role, Mod} -> %% role模块才加
            ProtoName = get_map_name(Map),
            case is_tos(ProtoName) of
                true ->
                    case lists:keyfind(Mod, 1, RoleModAcc) of
                        {_, NameList} ->
                            lists:keyreplace(Mod, 1, RoleModAcc, {Mod, [ProtoName|lists:delete(ProtoName, NameList)]});
                        _ ->
                            [{Mod, [ProtoName]}|RoleModAcc]
                    end;
                _ ->
                    RoleModAcc
            end;
        _ ->
            RoleModAcc
    end.

del_ignore_list([], RoleModList) ->
    RoleModList;
del_ignore_list([T|R], RoleModList) ->
    del_ignore_list(R, lists:keydelete(T, 1, RoleModList)).

is_tos(Map) when is_map(Map) ->
    {ok, Name} = maps:find(?MAP_KEY_NAME, Map),
    is_tos(Name);
is_tos(Name) ->
    Ts = string:tokens(to_list(Name), "_"),
    hd(Ts) =:= "m" andalso lists:last(Ts) =:= "tos".
%%is_toc(Map) when is_map(Map) ->
%%    {ok, Name} = maps:find(?MAP_KEY_NAME, Map),
%%    is_toc(Name);
%%is_toc(Name) ->
%%    Ts = string:tokens(to_list(Name), "_"),
%%    hd(Ts) =:= "m" andalso lists:last(Ts) =:= "toc".
%%
%%switch_tos_toc(Name) ->
%%    Name0 = string:tokens(Name, "_"),
%%    [Type|Name1] = lists:reverse(Name0),
%%    Name2 = lists:reverse(Name1),
%%    Res =
%%        case Type of
%%            "tos" -> string:join(Name2 ++ ["toc"], "_");
%%            "toc" -> string:join(Name2 ++ ["tos"], "_")
%%        end,
%%    Res.

%% ==================================================
%% 生成game_proto.proto
%% ==================================================
gen_proto_file(ProtoList) ->
    Head = "syntax = \"proto3\";~n",
    Maps = lists:foldl(
        fun(Map, Acc) ->
            Str = make_map_to_message(Map),
            [Str | Acc]
    end, [], ProtoList),
    write_file(?GOOGLE_GAME_PROTO, lists:flatten(lists:concat([Head, Maps])), [{encoding, latin1}]).

make_map_to_message(Map) ->
    #{?MAP_KEY_NAME := Name, ?MAP_KEY_NOTE := Note, ?MAP_KEY_FIELD := Fields} = Map,
    H = io_lib:format("message ~w \{ \/\/ ~s ~n", [Name, get_note(Note)]),
    F = get_field_define(Fields),
    T = io_lib:format("}~n", []),
    lists:flatten(lists:concat([H, F, T])).

get_field_define([]) -> io_lib:format("", []);
get_field_define(List) ->
    lists:foldr(
        fun({Name, DataType, Note}, {Acc, Count}) ->
            DataType = get_protobuf_type(DataType),
            {[io_lib:format("    ~s ~w = ~w; \/\/~s~n", [DataType, Name, Count, Note])
                | Acc], Count + 1}
    end, {[], 1}, List).

get_protobuf_type(int) -> "int32";
get_protobuf_type(long) -> "int64";
get_protobuf_type(string) -> "byte";
get_protobuf_type([P]) -> lists:concat(["repeated", P]);
get_protobuf_type(P) -> P.

%% =======================根据game_proto.proto生成gpb的hrl和erl==================================
gen_gpb() ->
    setup_code_path(),
    case filelib:is_file("./proto/game_proto.proto") of
        true ->
            gpb_compile:c([{i, "./proto/"}, {o_erl, "./src/proto/"}, {o_hrl, "./include/proto/"}], ["./proto/game_proto.proto"]),
            io:format("~s success~n", ["gen_gpb"]);
        _ ->
            io:format("Error: ~s.~n", ["can not find file: ./proto/game_proto.proto"]),
            show_usage(),
            halt(1)
    end.

setup_code_path() ->
    ScriptName = escript:script_name(),
    %% check symbolic link
    RawFile = find_raw_file(ScriptName),
    BinDir = filename:dirname(RawFile),
    EBinDir = filename:join([BinDir, "..", "ebin"]),
    %% add the gpb ebin path to we can have access to gpb_compile
    case code:add_pathz(EBinDir) of
        true ->
            try gpb_compile:module_info()
            catch error:undef ->
                io:format(
                    "Found dir ~p, but no usable gpb_compile.beam,~n"
                    "please verify that gpb has been built properly.~n",
                    [EBinDir]),
                halt(1)
            end,
            ok;
        {error, bad_directory} ->
            io:format(
                "Cannot find dir ~p~n"
                "please verify that gpb has been built properly.~n",
                [EBinDir]),
            halt(1)
    end.

find_raw_file(Name) ->
    find_raw_file(Name, file:read_link(Name)).

find_raw_file(Name, {error, _}) ->
    Name;

find_raw_file(Name, {ok, Name1}) ->
    %% for relative symbolic link
    %% if Name1 is absolute, then AbsoluteName is Name1
    DirName = filename:dirname(Name),
    AbsoluteName = filename:join(DirName, Name1),
    find_raw_file(AbsoluteName, file:read_link(AbsoluteName)).

show_usage() ->
    io:format("usage: ~s [options] X.proto [...]~n",
        [filename:basename(escript:script_name())]),
    gpb_compile:show_args().
%% =======================================gpb end =====================================

%%======================== 内部方法 =================================
to_list(List) when erlang:is_list(List) ->
    List;
to_list(Int) when erlang:is_integer(Int) ->
    erlang:integer_to_list(Int);
to_list(Binary) when erlang:is_binary(Binary) ->
    erlang:binary_to_list(Binary);
to_list(Atom) when erlang:is_atom(Atom) ->
    erlang:atom_to_list(Atom).




%%
%%to_string([]) ->
%%    "[]";
%%to_string(Default) ->
%%    to_list(Default).
%%
%%to_string(string, "") ->
%%    "\"\"";
%%to_string(_Type, Default) ->
%%    to_string(Default).
%%
get_map_name(Map) ->
    {ok, Name} = maps:find(?MAP_KEY_NAME, Map),
    Name.

%%get_map_router(Map) ->
%%    case  maps:find(?MAP_KEY_ROUTER, Map) of
%%        {ok,Router} -> Router;
%%        _ -> undefined
%%    end.
%%
%%
%%get_router_value(Router) when erlang:is_atom(Router) ->
%%    to_string(Router);
%%get_router_value(Router) ->
%%    case Router of
%%        {Value} ->
%%            to_string(Value);
%%        {Value, Mod} ->
%%            "{" ++ to_string(Value) ++ "," ++ to_string(Mod) ++ "}";
%%        _ ->
%%            to_list(Router)
%%    end.
%%
%%
%%get_field_default(Type) when erlang:is_list(Type) ->
%%    [];
%%get_field_default(Type) ->
%%    case Type of
%%        bool ->
%%            true;
%%        long ->
%%            0;
%%        int ->
%%            0;
%%        ulong ->
%%            0;
%%        int32 ->
%%            0;
%%        string ->
%%            "";
%%        _ ->
%%            undefined
%%    end.
%%
get_note([]) -> "";
get_note(Note) ->
    NoteList = to_list(Note),
    NoteList1 = string:strip(NoteList, left, $/),
    case NoteList1 of
        [_|_] ->
            NoteList2 = re:replace(NoteList1, "\"", "", [{return, list}, global]),
            NoteList3 = re:replace(NoteList2, "\<", "", [{return, list}, global]),
            NoteList4 = re:replace(NoteList3, "\>", "", [{return, list}, global]),
            NoteList5 = re:replace(NoteList4, "\/", "", [{return, list}, global]),
            NoteList6 = re:replace(NoteList5, [13], "", [{return, list}, global]); %%反斜杠。。。
        _ -> NoteList6 = NoteList1
    end,
    NoteList6.

