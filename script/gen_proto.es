#!/usr/bin/env escript
%% vim: set ft=erlang:
%% coding: utf-8
-include_lib("kernel/include/file.hrl").
-define(EXIT, halt(1)).
-define(EASY_MAKE_CONFIG, "./script/easy_make.config").
-define(GAME_PROTO, "./proto/game_proto.txt").
-define(PROTO_IDS, "./proto/proto_id.txt").
-define(GOOGLE_GAME_PROTO, "./proto/game_proto.proto").
-define(ALL_PB_HRL,             "./include/all_pb.hrl").
-define(COMMON_PB_HRL,          "./include/common_pb.hrl").
-define(GATEWAY_PROTO_ROUTER,   "./src/proto/gateway_proto_router.erl").
-define(GATEWAY_PROTO_ACK_ERL,      "./src/proto/gateway_proto_ack.erl").
%%-define(GATEWAY_PROTO_ACK_LUA,  "./front/proto/CfgAckProto.lua").
-define(GATEWAY_PROTO_ID,       "./src/proto/gateway_proto_id.erl").
%%-define(PROTO_LUA,              "./front/proto/Proto.lua"). %%协议的结构定义, COMPACT模式下为单行无注释文件
%%-define(PROTO_LUA_DOC,          "./front/proto/Proto.lua.info"). %%COMPACT模式下生成, 作为可读文档, 不打包到最终应用里
%%-define(PROTO_ALIAS_LUA,        "./front/proto/ProtoAlias.lua").
-define(COMMON_ERROR_NO_HRL,    "./include/proto/common_error_no.hrl").
-define(ALL_ERROR_NO_HRL,       "./include/proto/all_error_no.hrl").
%%-define(SWITCHING_MODULES,      "./src/common/module_switching.erl").
%%-define(TOS_REPLY_ERL,          "./src/common/tos_reply.erl").
-define(PROTO_HRL_DIR,          "./include/proto/").
-define(ERROR_CODE_LUA,         "./front/proto/CfgErrorCode.lua").
-define(ALL_CHECK_DIR, [
    "./src/proto/",
    "./include/proto/"
]).
-define(ROLE_MOD_IGNORE_LIST, []).

-define(MAP_KEY_NAME,    name).
-define(MAP_KEY_NOTE,    note).
-define(MAP_KEY_FIELD,   fields).
-define(MAP_KEY_ROUTER,  router).
-define(MAP_KEY_ERRCODE, err_code).
-define(MAP_KEY_ACK, ack).

-ifndef(IF).
-define(IF(C, T, F), (case (C) of true -> (T); false -> (F) end)).
-endif.

abort(Fmt, Args) ->
    io:format("ERROR: " ++ Fmt ++ "~n", Args),
    ?EXIT.

get_file_head() ->
    "%% ---------------------------------------------------------\n"
    "%% This file is generated by script, DO NOT EDIT!\n"
    "%% ---------------------------------------------------------\n".

main([]) ->
    ensure_dir(),
    gen_all().

gen_all() ->
    io:format("Processing......[please do not close this window!]~n"),
    {ok, [{proto_list, ProtoList}, {common_error_list, ErrorList}]} = file:consult(?GAME_PROTO),
    check_proto_list(ProtoList),
    io:format("~s success~n", ["proto_format_check"]),
    ProtoIDList = gen_proto_id(ProtoList),
    set_proto_id_txt(ProtoIDList),
    io:format("~s success~n", ["gen_proto_id"]),
    check_error_no(ProtoList, ErrorList),
    io:format("~s success~n", ["check_error_no"]),

    {CommonProtoList, HrlList, _RoleModList} = gen_hrl_list(ProtoList),
    FList =
        [
            {fun() -> gen_proto_file(ProtoList) end, "gen_proto_file"},
            {fun() -> gen_proto_router(ProtoList) end, "gen_proto_router"},
            {fun() -> gen_gateway_proto_id(ProtoList) end, "gen_gateway_proto_id"},
            {fun() -> gen_proto_ack_erl(ProtoList) end, "gen_proto_ack_erl"},
%%            {fun() -> gen_proto_ack_lua(ProtoList) end, "gen_proto_ack_lua"},
%%            {fun() -> gen_proto_switch(ProtoList) end, "gen_proto_switch"},
%%
            {fun() -> gen_proto_hrl(HrlList) end, "gen_proto_hrl"},
            {fun() -> gen_common_pb_hrl(CommonProtoList) end, "gen_common_pb_hrl"},
            {fun() -> gen_all_pb_hrl(HrlList) end, "gen_all_pb_hrl"},
            {fun() -> gen_common_error_no(CommonProtoList, ErrorList) end, "gen_common_error_no"},
            {fun() -> gen_all_error_no(ProtoList, ErrorList) end, "gen_all_error_no"}
        ],
    process_flag(trap_exit, true),
    PidList = [ {erlang:spawn_link(F), Msg} || {F, Msg} <- FList ],
    [] = lists:foldl(fun(_T, Acc)->
        receive
            {'EXIT', Pid, normal} ->
                {_, Msg} = lists:keyfind(Pid, 1, Acc),
                io:format("~s success~n", [Msg]),
                lists:keydelete(Pid, 1, Acc);
            {'EXIT', Pid, Err} ->
                {_, Msg} = lists:keyfind(Pid, 1, Acc),
                io:format("~s error: ~w~n", [Msg, Err]),
                [ catch erlang:exit(P, kill) || {P, _} <- Acc],
                erlang:throw({error, Pid});
            _Err ->
                io:format("~w error~n", [_Err]),
                [ catch erlang:exit(P, kill) || {P, _} <- Acc],
                erlang:throw({error, _Err})
        end
    end, PidList, PidList),
    process_flag(trap_exit, false),
    gen_gpb(),
    ok.
write_file(FileName, Bytes, Modes) ->
    ok = filelib:ensure_dir(FileName),
    ok = file:write_file(FileName, Bytes, Modes).

ensure_dir() ->
    [ensure_dir(Dir) || Dir <- ?ALL_CHECK_DIR].
ensure_dir(Dir) ->
    case filelib:is_dir(Dir) of
        true -> ok;
        false ->
            file:make_dir(Dir)
    end.


%%======================== 检查check_proto_list start ==============================
%% @doc 做game.proto文件的格式检查
check_proto_list(ProtoList) ->
    lists:foreach(fun(Map) ->
        case erlang:is_map(Map) of
            true ->
                check_map_name(Map),
                check_tos_router(Map);
            _ ->
                abort("map format error: ~w", [Map])
        end end, ProtoList),
    check_duplicates(ProtoList),
    check_missing_router().

%% @doc 检查map name
check_map_name(Map) ->
    case maps:find(?MAP_KEY_NAME, Map) of
        {ok, Name} ->
            Tokens = string:tokens(to_list(Name), "_"),
            FirstKey = hd(Tokens),
            LastKey = lists:last(Tokens),
            if FirstKey =:= "m", LastKey =:= "tos" -> ok;
                FirstKey =:= "m", LastKey =:= "toc" -> ok;
                FirstKey =:= "p" -> ok;
                true ->
                    abort("unknown name format: ~w", [Name])
            end;
        _ ->
            abort("missing name: ~w", [Map])
    end.

%% @doc 检查tos的map中有没有router
check_tos_router(#{?MAP_KEY_NAME := Name} = Map) ->
    Tokens = string:tokens(to_list(Name), "_"),
    FirstKey = hd(Tokens),
    LastKey = lists:last(Tokens),
    case FirstKey =:= "m" andalso LastKey =:= "tos" of
        true ->
            case maps:find(?MAP_KEY_ROUTER, Map) of
                {ok, _Router} ->
                    ok;
                _ ->
                    set_missing_router(Name)
            end;
        _ ->
            ignore
    end.

%% @doc map重复检查
check_duplicates(ProtoList) ->
    MapNameList = [Name || #{?MAP_KEY_NAME := Name} <- ProtoList],
    case get_duplicates_list(MapNameList) of
        [] ->
            ok;
        RepeatLs ->
            abort("redefining names: ~w", [RepeatLs])
    end.

get_duplicates_list(MapNameList) ->
    Uniques = lists:usort(MapNameList),
    lists:usort(MapNameList -- Uniques).

%% @doc tos缺少router属性的情况
check_missing_router() ->
    case get_missing_router() of
        [] ->
            ok;
        L ->
            abort("missing router: ~w", [L])
    end.

%% @doc 放置缺失的tos router
set_missing_router(Name) ->
    erlang:put(missing_router, [Name|get_missing_router()]).
get_missing_router() ->
    case erlang:get(missing_router) of
        undefined -> [];
        L -> L
    end.


%%======================== 生成proto_id.txt  start ==============================
%% @returns [{Name, ID}]
gen_proto_id(ProtoList) ->
    case filelib:is_file(?PROTO_IDS) of
        true ->
            {ok, ProtoIDList} = file:consult(?PROTO_IDS),
            IDs = [ID || {_, ID} <- ProtoIDList],
            case IDs of
                [] -> LastID = 0;
                _ -> LastID = lists:max(IDs)
            end,
            set_last_proto_id(LastID),
            AddList = get_add_list(ProtoList, ProtoIDList),
            do_append_file(AddList, ProtoIDList);
        _ ->
            {AddList, _} = lists:foldl(
                fun(#{?MAP_KEY_NAME := Name}, {AccList, AccCount}) ->
                    {[{Name, AccCount}|AccList], AccCount + 1}
                end, {[], 1}, ProtoList),
            do_append_file(AddList, [])
    end.

get_add_list(ProtoList, ProtoIDList) ->
    [{Name, inc_last_proto_id()} || #{?MAP_KEY_NAME := Name} <- ProtoList,
        not lists:keymember(Name, 1, ProtoIDList)].

do_append_file([], ProtoIDList) ->
    ProtoIDList;
do_append_file(AddList, OldList) ->
    ?IF(OldList =/= [], next, write_head()),
    AddList1 = lists:keysort(2, AddList),
    [file:write_file(?PROTO_IDS, io_lib:format("~w.~n", [Add]), [append]) || Add <- AddList1],
    AddList ++ OldList.

write_head() ->
    file:write_file(?PROTO_IDS, get_file_head()).

%% 设置proto_id.txt中的最后一个id
set_last_proto_id(LastID) ->
    erlang:put(last_proto_id, LastID).

get_last_proto_id() ->
    erlang:get(last_proto_id).

inc_last_proto_id() ->
    LastID = get_last_proto_id(),
    set_last_proto_id(LastID + 1) + 1.

%% @doc 将生成好的proto_id.txt内容放入内存
set_proto_id_txt(ProtoIDList) ->
    ets:new(proto_ids, [public, set, named_table, {read_concurrency, true}]),
    ets:insert(proto_ids, {all_proto_id, ProtoIDList}),
    [ets:insert(proto_ids, {{proto_id, Name}, ID}) || {Name, ID} <- ProtoIDList],
    ok.

%% @returns [{Name, ID}]
get_all_proto_id() ->
    [{_, ProtoIDList}] = ets:lookup(proto_ids, all_proto_id),
    ProtoIDList.


get_map_id(Map) when erlang:is_map(Map) ->
    {ok, Name} = maps:find(?MAP_KEY_NAME, Map),
    get_map_id(Name);
get_map_id(Name) ->
    get_proto_id(Name).
%% @returns ID | undefined
get_proto_id(Name) ->
    case ets:lookup(proto_ids, {proto_id, Name}) of
        [{_, ID}] -> ID;
        _ -> undefined
    end.


%% @doc ======================== 检查错误码合法性, 无重复 start ==============================
check_error_no(ProtoList, ErrorList) ->
    IDs1 = check_error_list(ErrorList, []),
    check_proto_error_list(ProtoList, IDs1).

check_error_list([{ErrorCode, _Define, _Note, _NotifyType}|ErrorList], Acc) ->
    case lists:member(ErrorCode, Acc) of
        true ->
            abort("duplicate error code: ~w", [ErrorCode]);
        _ ->
            check_error_list(ErrorList, [ErrorCode|Acc])
    end;
check_error_list([{ErrorCode, _Define, _Note}|ErrorList], Acc) ->
    case lists:member(ErrorCode, Acc) of
        true ->
            abort("duplicate error code: ~w", [ErrorCode]);
        _ ->
            check_error_list(ErrorList, [ErrorCode|Acc])
    end;
check_error_list([Other|_], _) ->
    abort("illegal error list format: ~w", [Other]);
check_error_list([], IDs) ->
    IDs.

check_proto_error_list([#{?MAP_KEY_NAME := Name} = Map|ProtoList], IDs) ->
    case maps:find(?MAP_KEY_ERRCODE, Map) of
        {ok, [_|_] = ErrorList} ->
            ID = get_map_id(Map),
            IDs2 = check_proto_error_list2(ErrorList, ID, Name, IDs);
        _ ->
            IDs2 = IDs
    end,
    check_proto_error_list(ProtoList, IDs2);
check_proto_error_list([], _) ->
    ok.

check_proto_error_list2([{Num, _Note}|ErrorList], ID, Name, IDs) ->
    ErrorCode = gen_error_code(ID, Name, Num),
    case lists:member(ErrorCode, IDs) of
        true ->
            abort("duplicate error code: ~w, for proto ~w", [ErrorCode, Name]);
        _ ->
            check_proto_error_list2(ErrorList, ID, Name, [ID|IDs])
    end;
check_proto_error_list2([{Num, Note, _ShowType}|ErrorList], ID, Name, IDs) ->
    check_proto_error_list2([{Num, Note}|ErrorList], ID, Name, IDs);
check_proto_error_list2([Other|_], _ID, Name, _IDs) ->
    abort("illegal error code format: ~w, for proto: ~w", [Other, Name]);
check_proto_error_list2([], _, _, IDs) ->
    IDs.

gen_error_code(ID, _Name, Num) when is_integer(Num), Num < 1000 ->
    ID * 1000 + Num;
gen_error_code(_ID, Name, Num) ->
    abort("illegal error code: ~w, for proto: ~w", [Num, Name]).

%% ======================== 检查错误码合法性, 无重复 end ==============================

%%=============================
%% @returns {L1, L2, L3}
%%          L1 := [ProtoMap], 未定义router的清单
%%          L2 := [{HrlName, [ProtoMap]}]
%%          L3 := [{RoleModule, [ProtoName]}]
gen_hrl_list(ProtoList) ->
    {OtherList, HrlList, RoleModList} =
        lists:foldl(
            fun(Map, {OtherAcc, HrlsAcc, RoleModAcc}) ->
                case maps:find(?MAP_KEY_ROUTER, Map) of
                    {ok, Router} ->
                        HrlName = get_hrl_name(Router),
                        case lists:keyfind(HrlName, 1, HrlsAcc) of
                            {_, HrlsAcc0} -> ok;
                            _ -> HrlsAcc0 = []
                        end,
                        HrlsAcc2 = lists:keystore(HrlName, 1, HrlsAcc, {HrlName, [Map|HrlsAcc0]}),
                        RoleModAcc2 = get_role_mod(Map, Router, RoleModAcc),
                        {OtherAcc, HrlsAcc2, RoleModAcc2};
                    _ ->
                        {[Map|OtherAcc], HrlsAcc, RoleModAcc}
                end
            end, {[], [], []}, ProtoList),
    RoleModList2 = del_ignore_list(?ROLE_MOD_IGNORE_LIST, RoleModList),
    {OtherList, HrlList, RoleModList2}.
get_hrl_name(Router) ->
    case Router of
        {Value} ->
            Value;
        {_Value, Mod} ->
            Mod;
        _ ->
            Router
    end.

get_role_mod(Map, Router, RoleModAcc) ->
    case Router of
        {role, Mod} -> %% role模块才加
            ProtoName = get_map_name(Map),
            case is_tos(ProtoName) of
                true ->
                    case lists:keyfind(Mod, 1, RoleModAcc) of
                        {_, NameList} ->
                            lists:keyreplace(Mod, 1, RoleModAcc, {Mod, [ProtoName|lists:delete(ProtoName, NameList)]});
                        _ ->
                            [{Mod, [ProtoName]}|RoleModAcc]
                    end;
                _ ->
                    RoleModAcc
            end;
        _ ->
            RoleModAcc
    end.

del_ignore_list([], RoleModList) ->
    RoleModList;
del_ignore_list([T|R], RoleModList) ->
    del_ignore_list(R, lists:keydelete(T, 1, RoleModList)).

is_tos(Map) when is_map(Map) ->
    {ok, Name} = maps:find(?MAP_KEY_NAME, Map),
    is_tos(Name);
is_tos(Name) ->
    Ts = string:tokens(to_list(Name), "_"),
    hd(Ts) =:= "m" andalso lists:last(Ts) =:= "tos".
is_toc(Map) when is_map(Map) ->
    {ok, Name} = maps:find(?MAP_KEY_NAME, Map),
    is_toc(Name);
is_toc(Name) ->
    Ts = string:tokens(to_list(Name), "_"),
    hd(Ts) =:= "m" andalso lists:last(Ts) =:= "toc".

%%switch_tos_toc(Name) ->
%%    Name0 = string:tokens(Name, "_"),
%%    [Type|Name1] = lists:reverse(Name0),
%%    Name2 = lists:reverse(Name1),
%%    Res =
%%        case Type of
%%            "tos" -> string:join(Name2 ++ ["toc"], "_");
%%            "toc" -> string:join(Name2 ++ ["tos"], "_")
%%        end,
%%    Res.

%% ==================================================
%% 生成game_proto.proto
%% ==================================================
gen_proto_file(ProtoList) ->
    Head = "syntax = \"proto3\";\n",
    Maps = lists:foldl(
        fun(Map, Acc) ->
            Str = make_map_to_message(Map),
            [Str | Acc]
    end, [], lists:reverse(ProtoList)),
    write_file(?GOOGLE_GAME_PROTO, lists:flatten(lists:concat([Head, Maps])), [{encoding, latin1}]).

make_map_to_message(Map) ->
    #{?MAP_KEY_NAME := Name, ?MAP_KEY_NOTE := Note, ?MAP_KEY_FIELD := Fields} = Map,
    H = io_lib:format("message ~w \{ \/\/ ~s ~n", [Name, get_note(Note)]),
    F = get_field_define(Fields),
    T = io_lib:format("}~n", []),
%%    io:format("~s", [lists:concat([H, F, T])]),
    lists:flatten(lists:concat([H, F, T])).

get_field_define([]) -> io_lib:format("", []);
get_field_define(List) ->
    {Fileds, _} = lists:foldl(
        fun({Name, DataType, Note}, {Acc, Count}) ->
            GDataType = get_protobuf_type(DataType),
            {[io_lib:format("    ~s ~w = ~w; \/\/~s~n", [GDataType, Name, Count, Note])
                | Acc], Count - 1}
    end, {[], erlang:length(List)}, lists:reverse(List)),
    Fileds.

get_protobuf_type(int) -> "int32";
get_protobuf_type(long) -> "int64";
get_protobuf_type(string) -> "bytes";
get_protobuf_type(bool) -> "bool";
get_protobuf_type([int]) -> "repeated int32";
get_protobuf_type([long]) -> "repeated int64";
get_protobuf_type([string]) -> "repeated bytes";
get_protobuf_type([P]) -> lists:concat(["repeated ", P]);
get_protobuf_type(P) -> P.

%%======================== 生成gateway_proto_router.erl  gen_proto_router start ==============================
gen_proto_router(ProtoList) ->
    Head = get_file_head() ++
        "-module(gateway_proto_router).\n"
        "-export([get_router/1]).\n\n",
    Map1 =
        lists:foldl(
            fun(Map, Acc1) ->
                Name = to_list(get_map_name(Map)),
                case is_tos(Name) of
                    true ->
                        Router = get_map_router(Map),
                        Router2 = get_router_value(Router),
                        TosMap = io_lib:format("get_router(~s) -> ~s;~n", [Name, Router2]),
                        NAcc1 = [TosMap|Acc1];
                    false ->
                        NAcc1 = Acc1
                end,
                NAcc1
            end, [], ProtoList),
    T1 = "get_router(_) -> undefined.\n",
    Code = lists:flatten(lists:concat([Head, lists:reverse(Map1), T1])),
    write_file(?GATEWAY_PROTO_ROUTER, Code, [{encoding, utf8}]),
    ok.


%%======================== 生成gateway_proto_id.erl  start ==============================
gen_gateway_proto_id(ProtoList) ->
    Head = get_file_head() ++
        "-module(gateway_proto_id).\n"
        "-export([get_map/1, get_fields/1]).\n\n",
    ProtoIDList = get_all_proto_id(),
    GetMapLs = [io_lib:format("get_map(~w) -> ~w;~nget_map(~w) -> ~w;~n", [ID, Name, Name, ID]) || {Name, ID} <- ProtoIDList],
    GetMapCode = GetMapLs ++ io_lib:format("get_map(Info) -> Info.~n~n", []),
    GetFieldsCode = gen_fields(ProtoList),
    Code = lists:flatten(lists:concat([Head, GetMapCode, GetFieldsCode])),
    write_file(?GATEWAY_PROTO_ID, Code, [{encoding, utf8}]),
    ok.

gen_fields(TocFields) ->
    lists:foldl(
        fun(#{?MAP_KEY_FIELD := FieldList, ?MAP_KEY_NAME := Name}, AccList) ->
            ID = get_map_id(Name),
            PointLs = get_proto_struct_pos(FieldList),
            case PointLs of
                [] -> AccList;
                _ ->
                    [io_lib:format("get_fields(~w) -> ~w;~nget_fields(~w) -> ~w;~n", [Name, PointLs, ID, PointLs])|AccList]
            end
        end, [], TocFields)
    ++ io_lib:format("get_fields(_) -> [].~n~n", []).

get_proto_struct_pos(FieldList) ->
    {PointL, _} = lists:foldl(
        fun(T, {AccList, Pos}) ->
            Type = erlang:element(2, T),
            case is_proto_struct(Type) of
                true -> {[Pos|AccList], Pos + 1};
                _ -> {AccList, Pos + 1}
            end
        end, {[], 2}, FieldList),
    PointL.

is_proto_struct([Type]) ->
    is_proto_struct(Type);
is_proto_struct(Type) ->
    get_field_default(Type) =:= undefined.


%%======================== 生成gateway_proto_id.erl  end ==============================

%%======================== 生成gateway_proto_router.erl  end ==============================
gen_proto_ack_erl(ProtoList) ->
    Head = get_file_head() ++
        "-module(gateway_proto_ack).\n"
        "-export([get_ack/1]).\n\n",
    Map1 =
        lists:foldl(
            fun(Map, Acc1) ->
                Ack = maps:get(?MAP_KEY_ACK, Map, 1),
                Name = to_list(get_map_name(Map)),
                TosMap = io_lib:format("get_ack(~s) -> ~w;~n", [Name, Ack]),
                [TosMap|Acc1]
            end, [], ProtoList),
    T1 = "get_ack(_) -> 0.\n",
    Code = lists:flatten(lists:concat([Head, lists:reverse(Map1), T1])),
    write_file(?GATEWAY_PROTO_ACK_ERL, Code, [{encoding, utf8}]),
    ok.

%% =============================== 生成各个模块的hrl end =================================
gen_proto_hrl(HrlList) ->
    filelib:ensure_dir(?PROTO_HRL_DIR),
    lists:foreach(
        fun({HrlName, ProtoList}) ->
            HrlNameUpcase = string:to_upper(to_list(HrlName)),
            IfDefine = io_lib:format("-ifndef(~s_HRL).\n-define(~s_HRL, true).\n", [HrlNameUpcase, HrlNameUpcase]),
            RecordList = gen_record_fields(ProtoList),
            ErrorList = gen_error_define(ProtoList),
            Content = "%% coding: latin-1\n%% created by script, DO NOT EDIT!\n\n"++ IfDefine ++ ErrorList ++ RecordList ++ "-endif.",
            Content2 = erlang:list_to_binary(Content),
            FileName = lists:concat([?PROTO_HRL_DIR, to_list(HrlName), ".hrl"]),
            case file:read_file(FileName) of
                {ok, Content2} ->
                    %%file:change_time(FileName, {erlang:date(), erlang:time()})
                    ok;
                _ ->
                    write_file(FileName, Content2, [{encoding, latin1}])
            end
        end, HrlList),
    %%删除当前proto下旧的hrl
    {ok, FileList} = file:list_dir_all(?PROTO_HRL_DIR),
    lists:foreach(
        fun(File) ->
            FileAtom = get_file_atom(File),
            case lists:keyfind(FileAtom, 1, HrlList) of
                {_, _} -> ignore;
                _ ->
                    DeleteFile = ?PROTO_HRL_DIR ++ File,
                    case DeleteFile of %% common_error_no.hrl不能删除
                        ?COMMON_ERROR_NO_HRL -> ignore;
                        ?ALL_ERROR_NO_HRL -> ignore;
                        _ -> file:delete(?PROTO_HRL_DIR ++ File)
                    end
            end
        end, FileList).
get_file_atom(File) ->
    [List|_] = string:tokens(File, "."),
    erlang:list_to_atom(List).

%%======================== 生成common_pb.hrl  gen_common_pb_hrl start ==============================
gen_common_pb_hrl(ProtoList) ->
    Code = gen_record_fields(ProtoList),
    Content = erlang:list_to_binary(["-ifndef(COMMON_PB_HRL).\n-define(COMMON_PB_HRL, true).\n", Code, "\n-endif."]),
    case file:read_file(?COMMON_PB_HRL) of
        {ok, Content} ->
            io:format("INFO: ~s not changed~n", [?COMMON_PB_HRL]);
        _ ->
            write_file(?COMMON_PB_HRL, Content, [{encoding, utf8}])
    end,
    ok.

gen_record_fields(ProtoList) ->
    lists:foldr(
        fun(Map, Acc) ->
            {ok, Name} = maps:find(?MAP_KEY_NAME, Map),
            case maps:find(?MAP_KEY_FIELD, Map) of
                {ok, Fields} ->
                    ok;
                _ ->
                    Fields = []
            end,
            lists:concat(["-record(", Name, ",{", gen_record_fields2(Fields), "}).\n", Acc])
        end, [], ProtoList).
gen_record_fields2(Fields) ->
    lists:foldl(
        fun(Field, Acc) ->
            Header = ?IF(Acc =:= [], "", ","),
            case Field of
                {Name, Type, Default, _Note} ->
                    next;
                {Name, Type, _Note} ->
                    Default = get_field_default(Type)
            end,
            Default2 = to_string(Type, Default),
            Code = ?IF(Default =:= undefined, lists:concat([Header, Name]), lists:concat([Header, Name, "=", to_string(Default2)])),
            lists:concat([Acc, Code])
        end, [], Fields).

%%======================== 生成all_pb.hrl  gen_all_pb_hrl start ==============================
gen_all_pb_hrl(HrlList) ->
    Code = gen_proto_hrls(HrlList, []),
    Content = erlang:list_to_binary(["-ifndef(ALL_PB_HRL).\n-define(ALL_PB_HRL, true).\n\n", Code, "\n-endif."]),
    case file:read_file(?ALL_PB_HRL) of
        {ok, Content} ->
            io:format("INFO: ~s not changed~n", [?ALL_PB_HRL]);
        _ ->
            write_file(?ALL_PB_HRL, Content, [{encoding, utf8}])
    end,
    ok.

gen_proto_hrls([], Acc) ->
    lists:concat(["-include(\"common_pb.hrl\").\n", Acc]);
gen_proto_hrls([{HrlName, _}|Ls], Acc) ->
    Acc2 = lists:concat(["-include(\"proto/", to_list(HrlName), ".hrl\").\n", Acc]),
    gen_proto_hrls(Ls, Acc2).

%%======================== 生成common_error_no.hrl start ==============================
gen_common_error_no(ProtoList, ErrorList) ->
    Header =
        "%% coding: latin-1\n"
        "%% created by script, do not edit it\n\n"
        "-ifndef(COMMON_ERROR_NO_HRL).\n"
        "-define(COMMON_ERROR_NO_HRL, common_error_no_hrl).\n\n",
    CommonList =
        lists:foldr(
            fun(Error, Acc) ->
                case Error of
                    {Code, Name, Note} -> ok;
                    {Code, Name, Note, _ShowType} -> ok
                end,
                lists:concat(["-define(", Name, ", ", Code, "). %%", get_note(Note), "\n"]) ++ Acc
            end, [], ErrorList),
    NormalList = gen_error_define(ProtoList),
    End = "-endif.",
    Code = Header ++ CommonList ++ NormalList ++ End,
    Content = erlang:list_to_binary(Code),
    case file:read_file(?COMMON_ERROR_NO_HRL) of
        {ok, Content} ->
            io:format("INFO: ~s not changed~n", [?COMMON_ERROR_NO_HRL]);
        _ ->
            write_file(?COMMON_ERROR_NO_HRL, Content, [{encoding, latin1}])
    end.

gen_error_define(ProtoList) ->
    lists:foldr(
        fun(Map, Acc2) ->
            case is_toc(get_map_name(Map)) of
                true ->
                    case maps:find(?MAP_KEY_ERRCODE, Map) of
                        {ok, [_|_] = ErrorCodeList} -> %% 不为空列表时才继续
                            ID = get_map_id(Map),
                            gen_error_define2(ErrorCodeList, to_list(get_map_name(Map)), ID) ++ "\n" ++ Acc2;
                        _ ->
                            Acc2
                    end;
                _ ->
                    Acc2
            end
        end, [], ProtoList).
gen_error_define2(ErrorList, Name, ID) ->
    Header = gen_error_macro_head(Name),
    lists:foldr(
        fun(Error, Acc) ->
            case Error of
                {Num, Note} -> ok;
                {Num, Note, _ShowType} -> ok
            end,
            MacroName = gen_error_macro(Header, Num),
            MacroVal = gen_error_code(ID, Name, Num),
            io_lib:format("-define(~s, ~w). %%~s~n", [MacroName, MacroVal, get_note(Note)]) ++ Acc
        end, [], ErrorList).
gen_error_macro_head(TocName) ->
    {ok, Pattern} = re:compile("m_(.*)_toc"),
    case re:run(TocName, Pattern, [global, {capture, all, list}]) of
        {_,[[_, Name]]} ->
            "ERROR_" ++ string:to_upper(Name);
        _ ->
            "ERROR_" ++ string:to_upper(to_list(TocName))
    end.
gen_error_macro(Header, Num) ->
    lists:flatten(io_lib:format("~s_~3..0w", [Header, Num])).

%%======================== 生成gen_all_error_no start =================================
gen_all_error_no(ProtoList, ErrorList) ->
    filelib:ensure_dir(?PROTO_HRL_DIR),
    Header =
        "%% coding: latin-1\n"
        "%% created by script, do not edit it\n\n"
        "-ifndef(ALL_ERROR_NO_HRL).\n"
        "-define(ALL_ERROR_NO_HRL, all_error_no_hrl).\n\n",
    CommonList =
        lists:foldr(
            fun(Error, Acc) ->
                case Error of
                    {Code, Name, Note} -> ok;
                    {Code, Name, Note, _ShowType} -> ok
                end,
                lists:concat(["-define(", Name, ", ", Code, "). %%", get_note(Note), "\n"]) ++ Acc
            end, [], ErrorList),
    NormalList = gen_error_define(ProtoList),
    End = "-endif.",
    Code = Header ++ CommonList ++ NormalList ++ End,
    Content = erlang:list_to_binary(Code),
    case file:read_file(?ALL_ERROR_NO_HRL) of
        {ok, Content} ->
            io:format("INFO: ~s not changed~n", [?ALL_ERROR_NO_HRL]);
        _ ->
            write_file(?ALL_ERROR_NO_HRL, Content, [{encoding, latin1}])
    end.

%% =======================根据game_proto.proto生成gpb的hrl和erl==================================
gen_gpb() ->
    setup_code_path(),
    case filelib:is_file("./proto/game_proto.proto") of
        true ->
            gpb_compile:c([{i, "./proto/"}, {o_erl, "./src/proto/"}, {o_hrl, "./include/proto/"}], ["./proto/game_proto.proto"]),
            io:format("~s success~n", ["gen_gpb"]);
        _ ->
            io:format("Error: ~s.~n", ["can not find file: ./proto/game_proto.proto"]),
            show_usage(),
            halt(1)
    end.

setup_code_path() ->
    ScriptName = escript:script_name(),
    %% check symbolic link
    RawFile = find_raw_file(ScriptName),
    BinDir = filename:dirname(RawFile),
    EBinDir = filename:join([BinDir, "..", "ebin"]),
    %% add the gpb ebin path to we can have access to gpb_compile
    case code:add_pathz(EBinDir) of
        true ->
            try gpb_compile:module_info()
            catch error:undef ->
                io:format(
                    "Found dir ~p, but no usable gpb_compile.beam,~n"
                    "please verify that gpb has been built properly.~n",
                    [EBinDir]),
                halt(1)
            end,
            ok;
        {error, bad_directory} ->
            io:format(
                "Cannot find dir ~p~n"
                "please verify that gpb has been built properly.~n",
                [EBinDir]),
            halt(1)
    end.

find_raw_file(Name) ->
    find_raw_file(Name, file:read_link(Name)).

find_raw_file(Name, {error, _}) ->
    Name;

find_raw_file(Name, {ok, Name1}) ->
    %% for relative symbolic link
    %% if Name1 is absolute, then AbsoluteName is Name1
    DirName = filename:dirname(Name),
    AbsoluteName = filename:join(DirName, Name1),
    find_raw_file(AbsoluteName, file:read_link(AbsoluteName)).

show_usage() ->
    io:format("usage: ~s [options] X.proto [...]~n",
        [filename:basename(escript:script_name())]),
    gpb_compile:show_args().
%% =======================================gpb end =====================================

%%======================== 内部方法 =================================
to_list(List) when erlang:is_list(List) ->
    List;
to_list(Int) when erlang:is_integer(Int) ->
    erlang:integer_to_list(Int);
to_list(Binary) when erlang:is_binary(Binary) ->
    erlang:binary_to_list(Binary);
to_list(Atom) when erlang:is_atom(Atom) ->
    erlang:atom_to_list(Atom).

to_string([]) ->
    "[]";
to_string(Default) ->
    to_list(Default).

to_string(string, "") ->
    "\"\"";
to_string(_Type, Default) ->
    to_string(Default).

get_map_name(Map) ->
    {ok, Name} = maps:find(?MAP_KEY_NAME, Map),
    Name.

get_map_router(Map) ->
    case  maps:find(?MAP_KEY_ROUTER, Map) of
        {ok,Router} -> Router;
        _ -> undefined
    end.

get_router_value(Router) when erlang:is_atom(Router) ->
    to_string(Router);
get_router_value(Router) ->
    case Router of
        {Value} ->
            to_string(Value);
        {Value, Mod} ->
            "{" ++ to_string(Value) ++ "," ++ to_string(Mod) ++ "}";
        _ ->
            to_list(Router)
    end.

get_field_default(Type) when erlang:is_list(Type) ->
    [];
get_field_default(Type) ->
    case Type of
        bool ->
            true;
        long ->
            0;
        int ->
            0;
        ulong ->
            0;
        int32 ->
            0;
        string ->
            "";
        _ ->
            undefined
    end.

get_note([]) -> "";
get_note(Note) ->
    NoteList = to_list(Note),
    NoteList1 = string:strip(NoteList, left, $/),
    case NoteList1 of
        [_|_] ->
            NoteList2 = re:replace(NoteList1, "\"", "", [{return, list}, global]),
            NoteList3 = re:replace(NoteList2, "\<", "", [{return, list}, global]),
            NoteList4 = re:replace(NoteList3, "\>", "", [{return, list}, global]),
            NoteList5 = re:replace(NoteList4, "\/", "", [{return, list}, global]),
            NoteList6 = re:replace(NoteList5, [13], "", [{return, list}, global]); %%反斜杠。。。
        _ -> NoteList6 = NoteList1
    end,
    NoteList6.

