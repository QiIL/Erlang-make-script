#!/usr/bin/env escript
%% vim: set ft=erlang:
%% coding: utf-8
-include_lib("kernel/include/file.hrl").
-define(EXIT, halt(1)).
-define(EASY_MAKE_CONFIG, "./script/easy_make.config").
-define(GAME_PROTO, "./proto/game_proto.txt").
-define(PROTO_IDS, "./proto/proto_id.txt").
-define(ALL_CHECK_DIR, [
    "./src/proto/",
    "./include/proto/"
]).

-define(MAP_KEY_NAME,    name).
-define(MAP_KEY_NOTE,    note).
-define(MAP_KEY_FIELD,   fields).
-define(MAP_KEY_ROUTER,  router).
-define(MAP_KEY_ERRCODE, err_code).
-define(MAP_KEY_ACK, ack).


-ifndef(IF).
-define(IF(C, T, F), (case (C) of true -> (T); false -> (F) end)).
-endif.

abort(Fmt, Args) ->
    io:format("ERROR: " ++ Fmt ++ "~n", Args),
    ?EXIT.

get_file_head() ->
    "%% ---------------------------------------------------------\n"
    "%% This file is generated by script, DO NOT EDIT!\n"
    "%% ---------------------------------------------------------\n".

main([]) ->
    ensure_dir(),
    gen_all().

gen_all() ->
    io:format("Processing......[please do not close this window!]~n"),
    {ok, [{proto_list, ProtoList}, {common_error_list, ErrorList}]} = file:consult(?GAME_PROTO),
    check_proto_list(ProtoList),
    io:format("~s success~n", ["proto_format_check"]),
    ProtoIDList = gen_proto_id(ProtoList),
    set_proto_id_txt(ProtoIDList),
    io:format("~s success~n", ["gen_proto_id"]),
    check_error_no(ProtoList, ErrorList),
    io:format("~s success~n", ["check_error_no"]),

%%    {CommonProtoList, HrlList, _RoleModList} = gen_hrl_list(ProtoList),
    FList =
        [
%%            {fun() -> gen_proto_file(ProtoList) end, "gen_proto_file"}
%%            {fun() -> gen_error_no_lua(ProtoList, ErrorList) end, "gen_error_no_lua"},
%%
%%            {fun() -> gen_proto_router(ProtoList) end, "gen_proto_router"},
%%            {fun() -> gen_gateway_proto_id(ProtoList) end, "gen_gateway_proto_id"},
%%            {fun() -> gen_proto_ack_erl(ProtoList) end, "gen_proto_ack_erl"},
%%            {fun() -> gen_proto_ack_lua(ProtoList) end, "gen_proto_ack_lua"},
%%            {fun() -> gen_proto_switch(ProtoList) end, "gen_proto_switch"},
%%
%%            {fun() -> gen_proto_hrl(HrlList) end, "gen_proto_hrl"},
%%            {fun() -> gen_common_pb_hrl(CommonProtoList) end, "gen_common_pb_hrl"},
%%            {fun() -> gen_common_error_no(CommonProtoList, ErrorList) end, "gen_common_error_no"},
%%            {fun() -> gen_all_pb_hrl(HrlList) end, "gen_all_pb_hrl"},
%%            {fun() -> gen_all_error_no(ProtoList, ErrorList) end, "gen_all_error_no"},
        ],
    process_flag(trap_exit, true),
    PidList = [ {erlang:spawn_link(F), Msg} || {F, Msg} <- FList ],
    [] = lists:foldl(fun(_T, Acc)->
        receive
            {'EXIT', Pid, normal} ->
                {_, Msg} = lists:keyfind(Pid, 1, Acc),
                io:format("~s success~n", [Msg]),
                lists:keydelete(Pid, 1, Acc);
            {'EXIT', Pid, Err} ->
                {_, Msg} = lists:keyfind(Pid, 1, Acc),
                io:format("~s error: ~w~n", [Msg, Err]),
                [ catch erlang:exit(P, kill) || {P, _} <- Acc],
                erlang:throw({error, Pid});
            _Err ->
                io:format("~w error~n", [_Err]),
                [ catch erlang:exit(P, kill) || {P, _} <- Acc],
                erlang:throw({error, _Err})
        end
    end, PidList, PidList),
    process_flag(trap_exit, false),
    gen_gpb(),
    ok.
%%write_file(FileName, Bytes, Modes) ->
%%    ok = filelib:ensure_dir(FileName),
%%    ok = file:write_file(FileName, Bytes, Modes).

ensure_dir() ->
    [ensure_dir(Dir) || Dir <- ?ALL_CHECK_DIR].
ensure_dir(Dir) ->
    case filelib:is_dir(Dir) of
        true -> ok;
        false ->
            file:make_dir(Dir)
    end.


%%======================== 检查check_proto_list start ==============================
%% @doc 做game.proto文件的格式检查
check_proto_list(ProtoList) ->
    lists:foreach(fun(Map) ->
        case erlang:is_map(Map) of
            true ->
                check_map_name(Map),
                check_tos_router(Map);
            _ ->
                abort("map format error: ~w", [Map])
        end end, ProtoList),
    check_duplicates(ProtoList),
    check_missing_router().

%% @doc 检查map name
check_map_name(Map) ->
    case maps:find(?MAP_KEY_NAME, Map) of
        {ok, Name} ->
            Tokens = string:tokens(to_list(Name), "_"),
            FirstKey = hd(Tokens),
            LastKey = lists:last(Tokens),
            if FirstKey =:= "m", LastKey =:= "tos" -> ok;
                FirstKey =:= "m", LastKey =:= "toc" -> ok;
                FirstKey =:= "p" -> ok;
                true ->
                    abort("unknown name format: ~w", [Name])
            end;
        _ ->
            abort("missing name: ~w", [Map])
    end.

%% @doc 检查tos的map中有没有router
check_tos_router(#{?MAP_KEY_NAME := Name} = Map) ->
    Tokens = string:tokens(to_list(Name), "_"),
    FirstKey = hd(Tokens),
    LastKey = lists:last(Tokens),
    case FirstKey =:= "m" andalso LastKey =:= "tos" of
        true ->
            case maps:find(?MAP_KEY_ROUTER, Map) of
                {ok, _Router} ->
                    ok;
                _ ->
                    set_missing_router(Name)
            end;
        _ ->
            ignore
    end.

%% @doc map重复检查
check_duplicates(ProtoList) ->
    MapNameList = [Name || #{?MAP_KEY_NAME := Name} <- ProtoList],
    case get_duplicates_list(MapNameList) of
        [] ->
            ok;
        RepeatLs ->
            abort("redefining names: ~w", [RepeatLs])
    end.

get_duplicates_list(MapNameList) ->
    Uniques = lists:usort(MapNameList),
    lists:usort(MapNameList -- Uniques).

%% @doc tos缺少router属性的情况
check_missing_router() ->
    case get_missing_router() of
        [] ->
            ok;
        L ->
            abort("missing router: ~w", [L])
    end.

%% @doc 放置缺失的tos router
set_missing_router(Name) ->
    erlang:put(missing_router, [Name|get_missing_router()]).
get_missing_router() ->
    case erlang:get(missing_router) of
        undefined -> [];
        L -> L
    end.


%%======================== 生成proto_id.txt  start ==============================
%% @returns [{Name, ID}]
gen_proto_id(ProtoList) ->
    case filelib:is_file(?PROTO_IDS) of
        true ->
            {ok, ProtoIDList} = file:consult(?PROTO_IDS),
            IDs = [ID || {_, ID} <- ProtoIDList],
            case IDs of
                [] -> LastID = 0;
                _ -> LastID = lists:max(IDs)
            end,
            set_last_proto_id(LastID),
            AddList = get_add_list(ProtoList, ProtoIDList),
            do_append_file(AddList, ProtoIDList);
        _ ->
            {AddList, _} = lists:foldl(
                fun(#{?MAP_KEY_NAME := Name}, {AccList, AccCount}) ->
                    {[{Name, AccCount}|AccList], AccCount + 1}
                end, {[], 1}, ProtoList),
            do_append_file(AddList, [])
    end.

get_add_list(ProtoList, ProtoIDList) ->
    [{Name, inc_last_proto_id()} || #{?MAP_KEY_NAME := Name} <- ProtoList,
        not lists:keymember(Name, 1, ProtoIDList)].

do_append_file([], ProtoIDList) ->
    ProtoIDList;
do_append_file(AddList, OldList) ->
    ?IF(OldList =/= [], next, write_head()),
    AddList1 = lists:keysort(2, AddList),
    [file:write_file(?PROTO_IDS, io_lib:format("~w.~n", [Add]), [append]) || Add <- AddList1],
    AddList ++ OldList.

write_head() ->
    file:write_file(?PROTO_IDS, get_file_head()).

%% 设置proto_id.txt中的最后一个id
set_last_proto_id(LastID) ->
    erlang:put(last_proto_id, LastID).

get_last_proto_id() ->
    erlang:get(last_proto_id).

inc_last_proto_id() ->
    LastID = get_last_proto_id(),
    set_last_proto_id(LastID + 1) + 1.

%% @doc 将生成好的proto_id.txt内容放入内存
set_proto_id_txt(ProtoIDList) ->
    ets:new(proto_ids, [public, set, named_table, {read_concurrency, true}]),
    ets:insert(proto_ids, {all_proto_id, ProtoIDList}),
    [ets:insert(proto_ids, {{proto_id, Name}, ID}) || {Name, ID} <- ProtoIDList],
    ok.

%%%% @returns [{Name, ID}]
%%get_all_proto_id() ->
%%    [{_, ProtoIDList}] = ets:lookup(proto_ids, all_proto_id),
%%    ProtoIDList.
%%

get_map_id(Map) when erlang:is_map(Map) ->
    {ok, Name} = maps:find(?MAP_KEY_NAME, Map),
    get_map_id(Name);
get_map_id(Name) ->
    get_proto_id(Name).
%% @returns ID | undefined
get_proto_id(Name) ->
    case ets:lookup(proto_ids, {proto_id, Name}) of
        [{_, ID}] -> ID;
        _ -> undefined
    end.


%% @doc ======================== 检查错误码合法性, 无重复 start ==============================
check_error_no(ProtoList, ErrorList) ->
    IDs1 = check_error_list(ErrorList, []),
    check_proto_error_list(ProtoList, IDs1).

check_error_list([{ErrorCode, _Define, _Note, _NotifyType}|ErrorList], Acc) ->
    case lists:member(ErrorCode, Acc) of
        true ->
            abort("duplicate error code: ~w", [ErrorCode]);
        _ ->
            check_error_list(ErrorList, [ErrorCode|Acc])
    end;
check_error_list([{ErrorCode, _Define, _Note}|ErrorList], Acc) ->
    case lists:member(ErrorCode, Acc) of
        true ->
            abort("duplicate error code: ~w", [ErrorCode]);
        _ ->
            check_error_list(ErrorList, [ErrorCode|Acc])
    end;
check_error_list([Other|_], _) ->
    abort("illegal error list format: ~w", [Other]);
check_error_list([], IDs) ->
    IDs.

check_proto_error_list([#{?MAP_KEY_NAME := Name} = Map|ProtoList], IDs) ->
    case maps:find(?MAP_KEY_ERRCODE, Map) of
        {ok, [_|_] = ErrorList} ->
            ID = get_map_id(Map),
            IDs2 = check_proto_error_list2(ErrorList, ID, Name, IDs);
        _ ->
            IDs2 = IDs
    end,
    check_proto_error_list(ProtoList, IDs2);
check_proto_error_list([], _) ->
    ok.

check_proto_error_list2([{Num, _Note}|ErrorList], ID, Name, IDs) ->
    ErrorCode = gen_error_code(ID, Name, Num),
    case lists:member(ErrorCode, IDs) of
        true ->
            abort("duplicate error code: ~w, for proto ~w", [ErrorCode, Name]);
        _ ->
            check_proto_error_list2(ErrorList, ID, Name, [ID|IDs])
    end;
check_proto_error_list2([{Num, Note, _ShowType}|ErrorList], ID, Name, IDs) ->
    check_proto_error_list2([{Num, Note}|ErrorList], ID, Name, IDs);
check_proto_error_list2([Other|_], _ID, Name, _IDs) ->
    abort("illegal error code format: ~w, for proto: ~w", [Other, Name]);
check_proto_error_list2([], _, _, IDs) ->
    IDs.

gen_error_code(ID, _Name, Num) when is_integer(Num), Num < 1000 ->
    ID * 1000 + Num;
gen_error_code(_ID, Name, Num) ->
    abort("illegal error code: ~w, for proto: ~w", [Num, Name]).

%% ======================== 检查错误码合法性, 无重复 end ==============================

%% =======================根据game_proto.proto生成gpb的hrl和erl==================================
gen_gpb() ->
    setup_code_path(),
    case filelib:is_file("./proto/game_proto.proto") of
        true ->
            gpb_compile:c([{i, "./proto/"}, {o_erl, "./src/proto/"}, {o_hrl, "./include/proto/"}], ["./proto/game_proto.proto"]),
            io:format("~s success~n", ["gen_gpb"]);
        _ ->
            io:format("Error: ~s.~n", ["can not find file: ./proto/game_proto.proto"]),
            show_usage(),
            halt(1)
    end.

setup_code_path() ->
    ScriptName = escript:script_name(),
    %% check symbolic link
    RawFile = find_raw_file(ScriptName),
    BinDir = filename:dirname(RawFile),
    EBinDir = filename:join([BinDir, "..", "ebin"]),
    %% add the gpb ebin path to we can have access to gpb_compile
    case code:add_pathz(EBinDir) of
        true ->
            try gpb_compile:module_info()
            catch error:undef ->
                io:format(
                    "Found dir ~p, but no usable gpb_compile.beam,~n"
                    "please verify that gpb has been built properly.~n",
                    [EBinDir]),
                halt(1)
            end,
            ok;
        {error, bad_directory} ->
            io:format(
                "Cannot find dir ~p~n"
                "please verify that gpb has been built properly.~n",
                [EBinDir]),
            halt(1)
    end.

find_raw_file(Name) ->
    find_raw_file(Name, file:read_link(Name)).

find_raw_file(Name, {error, _}) ->
    Name;

find_raw_file(Name, {ok, Name1}) ->
    %% for relative symbolic link
    %% if Name1 is absolute, then AbsoluteName is Name1
    DirName = filename:dirname(Name),
    AbsoluteName = filename:join(DirName, Name1),
    find_raw_file(AbsoluteName, file:read_link(AbsoluteName)).

show_usage() ->
    io:format("usage: ~s [options] X.proto [...]~n",
        [filename:basename(escript:script_name())]),
    gpb_compile:show_args().
%% =======================================gpb end =====================================

%%======================== 内部方法 =================================
to_list(List) when erlang:is_list(List) ->
    List;
to_list(Int) when erlang:is_integer(Int) ->
    erlang:integer_to_list(Int);
to_list(Binary) when erlang:is_binary(Binary) ->
    erlang:binary_to_list(Binary);
to_list(Atom) when erlang:is_atom(Atom) ->
    erlang:atom_to_list(Atom).




%%
%%to_string([]) ->
%%    "[]";
%%to_string(Default) ->
%%    to_list(Default).
%%
%%to_string(string, "") ->
%%    "\"\"";
%%to_string(_Type, Default) ->
%%    to_string(Default).
%%
%%get_map_name(Map) ->
%%    {ok, Name} = maps:find(?MAP_KEY_NAME, Map),
%%    Name.
%%
%%get_map_router(Map) ->
%%    case  maps:find(?MAP_KEY_ROUTER, Map) of
%%        {ok,Router} -> Router;
%%        _ -> undefined
%%    end.
%%
%%
%%get_router_value(Router) when erlang:is_atom(Router) ->
%%    to_string(Router);
%%get_router_value(Router) ->
%%    case Router of
%%        {Value} ->
%%            to_string(Value);
%%        {Value, Mod} ->
%%            "{" ++ to_string(Value) ++ "," ++ to_string(Mod) ++ "}";
%%        _ ->
%%            to_list(Router)
%%    end.
%%
%%
%%get_field_default(Type) when erlang:is_list(Type) ->
%%    [];
%%get_field_default(Type) ->
%%    case Type of
%%        bool ->
%%            true;
%%        long ->
%%            0;
%%        int ->
%%            0;
%%        ulong ->
%%            0;
%%        int32 ->
%%            0;
%%        string ->
%%            "";
%%        _ ->
%%            undefined
%%    end.
%%
%%get_note([]) -> "";
%%get_note(Note) ->
%%    NoteList = to_list(Note),
%%    NoteList1 = string:strip(NoteList, left, $/),
%%    case NoteList1 of
%%        [_|_] ->
%%            NoteList2 = re:replace(NoteList1, "\"", "", [{return, list}, global]),
%%            NoteList3 = re:replace(NoteList2, "\<", "", [{return, list}, global]),
%%            NoteList4 = re:replace(NoteList3, "\>", "", [{return, list}, global]),
%%            NoteList5 = re:replace(NoteList4, "\/", "", [{return, list}, global]),
%%            NoteList6 = re:replace(NoteList5, [13], "", [{return, list}, global]); %%反斜杠。。。
%%        _ -> NoteList6 = NoteList1
%%    end,
%%    NoteList6.

